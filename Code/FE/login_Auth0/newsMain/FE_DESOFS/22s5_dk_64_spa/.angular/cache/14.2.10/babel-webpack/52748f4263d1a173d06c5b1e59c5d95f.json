{"ast":null,"code":"import * as THREE from 'three';\nimport { connectionData, roundaboutData, streetData } from '../default_data';\nexport class Streets {\n  constructor(nodes, edges) {\n    this.loaded = false;\n    this.object = new THREE.Group();\n    let checks = [];\n    const texture = new THREE.TextureLoader().load(streetData.streetURL);\n    texture.wrapS = THREE.RepeatWrapping;\n    texture.wrapT = THREE.RepeatWrapping;\n    texture.magFilter = THREE.LinearFilter;\n    texture.minFilter = THREE.LinearMipmapLinearFilter;\n    const textureCon = texture.clone();\n    textureCon.repeat.set(1, connectionData.textureRepeatDivisor);\n\n    for (let node of nodes) {\n      let warehouses = [];\n      let connectionGroup = new THREE.Group();\n      let roadGroup = new THREE.Group();\n\n      for (let edge of edges) {\n        // Sanity Checks\n        // Verify 2-way connections.\n        let targetNode = undefined;\n\n        if (edge.whPartida == node.id && warehouses.find(looking => looking == edge.whChegada) == undefined) {\n          targetNode = nodes.find(node => node.id == edge.whChegada);\n          warehouses.push(edge.whChegada);\n        }\n\n        if (edge.whChegada == node.id && warehouses.find(looking => looking == edge.whPartida) == undefined) {\n          targetNode = nodes.find(node => node.id == edge.whPartida);\n          warehouses.push(edge.whPartida);\n        } // Verify if it even exists to begin with. If not, skip.\n\n\n        if (targetNode == undefined) {\n          continue;\n        } // Verify if edge already exists.\n\n\n        if (checks.find(check => check === node.id.concat(targetNode.id)) !== undefined || checks.find(check => check === targetNode.id.concat(node.id)) !== undefined) {\n          continue;\n        }\n\n        checks.push(node.id.concat(targetNode.id)); // Sanity Checks End.\n        // Model connections begin.\n\n        let conLength = connectionData.k * (connectionData.width * roundaboutData.k / 2);\n        let geometryConn = new THREE.PlaneGeometry(connectionData.width, conLength, 30, 30);\n        let materialConn = new THREE.MeshPhongMaterial({\n          color: 0xffffff,\n          side: THREE.DoubleSide,\n          map: textureCon\n        });\n        let connection1 = new THREE.Mesh(geometryConn, materialConn);\n        let connection2 = new THREE.Mesh(geometryConn, materialConn);\n        connection1.receiveShadow = true;\n        connection2.receiveShadow = true;\n        let x = targetNode.x - node.x;\n        let y = targetNode.y - node.y;\n        let orientation = Math.atan2(y, x) + Math.PI / 2;\n        connection1.position.set(node.x, node.y, node.z);\n        connection1.rotateZ(orientation);\n        connection1.translateY(conLength / 2 * -1);\n        connection2.position.set(targetNode.x, targetNode.y, targetNode.z);\n        connection2.rotateZ(orientation);\n        connection2.translateY(conLength / 2);\n        connectionGroup.add(connection1);\n        connectionGroup.add(connection2); // Model connections end.\n        // Model roads begin.\n\n        let z = targetNode.z - node.z;\n        let projection = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) - conLength * 2;\n        let roadLength = Math.sqrt(Math.pow(projection, 2) + Math.pow(z, 2));\n        let incline = Math.atan2(z, projection) * -1;\n        let textureRoad = texture.clone();\n        textureRoad.repeat.set(1, roadLength / streetData.textureRepeatDivisor);\n        let geometryRoad = new THREE.PlaneGeometry(connectionData.width, roadLength, 30, 30);\n        let materialRoad = new THREE.MeshPhongMaterial({\n          color: 0xffffff,\n          side: THREE.DoubleSide,\n          map: textureRoad\n        });\n        let road = new THREE.Mesh(geometryRoad, materialRoad);\n        road.receiveShadow = true;\n        road.position.set((node.x + targetNode.x) / 2, (node.y + targetNode.y) / 2, (node.z + targetNode.z) / 2);\n        road.rotateZ(orientation);\n        road.rotateX(incline);\n        roadGroup.add(road); // Model roads end.\n\n        this.object.add(connectionGroup);\n        this.object.add(roadGroup);\n      }\n    }\n\n    this.loaded = true;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}