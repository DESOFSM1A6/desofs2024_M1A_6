{"ast":null,"code":"import { GraphEdge } from './graph_edge';\nimport { GraphNode } from './graph_node';\nimport { forkJoin } from 'rxjs';\nimport { cartesianData } from '../default_data';\nimport { WarehouseMap } from 'src/app/Mapper/WarehouseMap';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"src/app/Services/warehouse.service\";\nimport * as i2 from \"src/app/Services/percurso.service\";\nexport let GraphCreator = /*#__PURE__*/(() => {\n  class GraphCreator {\n    constructor(warehouseService, percursoService) {\n      this.warehouseService = warehouseService;\n      this.percursoService = percursoService; // Array que contém os Armazéns(nodes)\n\n      this.nodes = []; // Array que contém os Percursos(edges)\n\n      this.edges = [];\n    } // Atualiza o Array nodes e o Array edges\n\n\n    generateGraph() {\n      // Observable calls do not depend on eachother, but it is within our interest that they resolve simultaneously for loading purposes.\n      return forkJoin({\n        warehouses: this.warehouseService.getWarehouses(),\n        paths: this.percursoService.getPercursos()\n      });\n    }\n\n    buildNodes(warehousesDTO) {\n      let warehouses = WarehouseMap.toViewModelList(warehousesDTO); // Geographical limitations.\n\n      let longitudeLowerLimit = Math.min(...warehouses.map(warehouse => warehouse.longitude));\n      let longitudeUpperLimit = Math.max(...warehouses.map(warehouse => warehouse.longitude));\n      let latitudeLowerLimit = Math.min(...warehouses.map(warehouse => warehouse.latitude));\n      let latitudeUpperLimit = Math.max(...warehouses.map(warehouse => warehouse.latitude));\n      let altitudeLowerLimit = Math.min(...warehouses.map(warehouse => warehouse.altitude));\n      let altitudeUpperLimit = Math.max(...warehouses.map(warehouse => warehouse.altitude));\n\n      for (let warehouse of warehouses) {\n        // Prevent duplicates from multiple refreshes of the page as this is a singleton provider.\n        if (this.nodes.filter(node => node.id === warehouse.id).length > 0) {\n          continue;\n        }\n\n        let x = this.geographicalToCartesian(warehouse.longitude, longitudeLowerLimit, longitudeUpperLimit, cartesianData.xLowerLimit, cartesianData.xUpperLimit);\n        let y = this.geographicalToCartesian(warehouse.latitude, latitudeLowerLimit, latitudeUpperLimit, cartesianData.yLowerLimit, cartesianData.yUpperLimit);\n        let z = this.geographicalToCartesian(warehouse.altitude, altitudeLowerLimit, altitudeUpperLimit, cartesianData.zLowerLimit, cartesianData.zUpperLimit);\n        let node = new GraphNode(warehouse.id, warehouse.description, x, y, z);\n        this.nodes.push(node);\n      }\n\n      ;\n    }\n\n    buildEdges(percursos) {\n      for (let percurso of percursos) {\n        // Prevent duplicates from multiple refreshes of the page as this is a singleton provider.\n        if (this.edges.filter(edge => edge.whChegada === percurso.whChegada && edge.whPartida === percurso.whPartida).length > 0) {\n          continue;\n        }\n\n        let edge = new GraphEdge(percurso.whPartida, percurso.whChegada, percurso.distancia);\n        this.edges.push(edge);\n      }\n    }\n\n    geographicalToCartesian(coord, geoLowerLimit, geoUpperLimit, cartLowerLimit, cartUpperLimit) {\n      if (geoUpperLimit - geoLowerLimit === 0) {\n        return 0;\n      }\n\n      return (cartUpperLimit - cartLowerLimit) / (geoUpperLimit - geoLowerLimit) * (coord - geoLowerLimit) + cartLowerLimit;\n    }\n\n  }\n\n  GraphCreator.ɵfac = function GraphCreator_Factory(t) {\n    return new (t || GraphCreator)(i0.ɵɵinject(i1.WarehouseService), i0.ɵɵinject(i2.PercursoService));\n  };\n\n  GraphCreator.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: GraphCreator,\n    factory: GraphCreator.ɵfac,\n    providedIn: 'root'\n  });\n  return GraphCreator;\n})();","map":null,"metadata":{},"sourceType":"module"}